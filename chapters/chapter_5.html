<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Surface Normals and Multiple Objects - ray-tracing in one weekend</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../chapters/introduce.html">Introduce</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_1.html"><strong aria-hidden="true">1.</strong> Output an Image</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_2.html"><strong aria-hidden="true">2.</strong> The vec3 Struct</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_3.html"><strong aria-hidden="true">3.</strong> Rays, a Simple Camera, and Background</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_4.html"><strong aria-hidden="true">4.</strong> Adding a Sphere</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_5.html" class="active"><strong aria-hidden="true">5.</strong> Surface Normals and Multiple Objects</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_6.html"><strong aria-hidden="true">6.</strong> Antialiasing</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_7.html"><strong aria-hidden="true">7.</strong> Diffuse Materials</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ray-tracing in one weekend</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dupeiran001/rust-ray-tracing-in-one-weekend" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="surface-normals-and-multiple-objects"><a class="header" href="#surface-normals-and-multiple-objects">Surface Normals and Multiple Objects</a></h1>
<h2 id="shading-with-surface-normals"><a class="header" href="#shading-with-surface-normals">Shading with Surface Normals</a></h2>
<p>First, let’s get ourselves a surface normal so we can shade. This is a vector that is perpendicular to the surface at the point of intersection. There are two design decisions to make for normals. The first is whether these normals are unit length. That is convenient for shading so I will say yes, but I won’t enforce that in the code. This could allow subtle bugs, so be aware this is personal preference as are most design decisions like that. For a sphere, the outward normal is in the direction of the hit point minus the center:</p>
<p><img src="../resources/pictures/fig-1.05-sphere-normal.jpg" alt="Sphere surface-normal geometry" /></p>
<p>On the earth, this implies that the vecor form the earth's center to you points straight up. Let's throw that into the code now, and shade it. We don't have any lights or anything yet, so let's just visualize the normals with a color map. A common trick used for visual normals (because it's easy and somewhat intuitive to assume \(\textbf{n}\) is a unit length vector -- so each component is between -1 and 1) is to map each component to the interval from 0 to 1, and then map x/y/z to r/g/b. For the normal, we need the hit point, not just whether we hit or not. We only have one sphere in the scene, and it's directly in front of the camera, so we won't worry about negative values of \(t\) yet. We'll just assume the closest hit point (smallest \(t\)). These changes in the code let us compute and visualize \(\textbf{n}\):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn hit_sphere(center: &amp;Point3, radius: f64, r: &amp;Ray) -&gt; f64 {
    let oc: Vec3 = r.origin() - *center;
    let a = Vec3::dot(&amp;r.direction(), &amp;r.direction());
    let b = 2.0 * Vec3::dot(&amp;oc, &amp;r.direction());
    let c = Vec3::dot(&amp;oc, &amp;oc) - radius * radius;
    let discriminant = b * b - 4.0 * a * c;
    if discriminant &lt; 0.0 {
        -1.0
    } else {
        (-b - discriminant.sqrt()) / (2.0 * a)
    }
}

fn ray_color(r: &amp;Ray) -&gt; Color {
    let t = hit_sphere(&amp;Point3::from(0f64, 0f64, -1f64), 0.5, r);
    if t &gt; 0.0 {
        let n = Vec3::unit_vector(&amp;(r.at(t) - Vec3::from(0.0, 0.0, -1.0)));
        return 0.5 * Color::from(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
    }
    let unit_direction: Vec3 = r.direction().unit_vector();
    let t = 0.5 * (unit_direction.y() + 1f64);
    (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
}
<span class="boring">}</span></code></pre></pre>
<p>And that yields this picture:</p>
<p><img src="../resources/pictures/img-1.04-normals-sphere.png" alt="A sphere colored according to its normal vectors" /></p>
<h2 id="simplifying-the-ray-sphere-intersection-code"><a class="header" href="#simplifying-the-ray-sphere-intersection-code">Simplifying the Ray-Sphere Intersection Code</a></h2>
<p>Let's revisit the ray-sphere equation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hit_sphere(center: &amp;Point3, radius: f64, r: &amp;Ray) -&gt; f64 {
    let oc: Vec3 = r.origin() - *center;
    let a = Vec3::dot(&amp;r.direction(), &amp;r.direction());
    let b = 2.0 * Vec3::dot(&amp;oc, &amp;r.direction());
    let c = Vec3::dot(&amp;oc, &amp;oc) - radius * radius;
    let discriminant = b * b - 4.0 * a * c;
    if discriminant &lt; 0.0 {
        -1.0
    } else {
        (-b - discriminant.sqrt()) / (2.0 * a)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First recall that a vector dotted with itself is equal to the squared length of that vector.</p>
<p>Second, notice how the equation for <strong>b</strong> has a factor of two in it. Consider what happens to the quardratic equation if \(b=2h\):</p>
<p>$$
\frac{-b\pm\sqrt{b^2-4ac}}{2a} \\
= \frac{-2h\pm\sqrt{(2h)^2-4ac}}{2a} \\
= \frac{-2h\pm2\sqrt{h^2-ac}}{2a} \\
= \frac{-h\pm\sqrt{h^2-ac}}{a}
$$</p>
<p>Using these observations, we can now simplify the sphere-intersection code to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hit_sphere(center: &amp;Point3, radius: f64, r: &amp;Ray) -&gt; f64 {
    let oc: Vec3 = r.origin() - *center;
    let a = r.direction().length_squared();
    let half_b = Vec3::dot(&amp;oc, &amp;r.direction());
    let c = oc.length_squared() - radius * radius;
    let discriminant = half_b * half_b - a * c;
    if discriminant &lt; 0.0 {
        -1.0
    } else {
        (-half_b - discriminant.sqrt()) / a
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="an-abstraction-for-hittable-objects"><a class="header" href="#an-abstraction-for-hittable-objects">An Abstraction for Hittable Objects</a></h2>
<p>Now, how about several spheres? While it is tempting to have an array of spheres, a very clean solution is the make an “abstract class” for anything a ray might hit, and make both a sphere and a list of spheres just something you can hit. What that class should be called is something of a quandary —- calling it an “object” would be good if not for “object oriented” programming. “Surface” is often used, with the weakness being maybe we will want volumes. “hittable” emphasizes the member function that unites them. I don’t love any of these, but I will go with “hittable”.</p>
<p>This <strong>hittable</strong> abstract class will have a hit function that takes in a ray. Most ray tracers have found it convenient to add a valid interval for hits \(t_{min}\) to \(t_{max}\), so the hit only “counts” if \(t_{min}&lt;t&lt;t_{max}\). For the initial rays this is positive \(t\), but as we will see, it can help some details in the code to have an interval \(t_{min}\) to \(t_{max}\). One design question is whether to do things like compute the normal if we hit something. We might end up hitting something closer as we do our search, and we will only need the normal of the closest thing. I will go with the simple solution and compute a bundle of stuff I will store in some structure. Here’s the abstract class:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::ray::*;
use crate::vec3::*;

pub struct HitRecord {
    p: Point3,
    normal: Vec3,
    t: f64,
}

impl HitRecord {
    pub fn new() -&gt; Self {
        HitRecord {
            p: Point3::new(),
            normal: Vec3::new(),
            t: Default::default(),
        }
    }

    pub fn from(point: Point3, n: Vec3, hit_t: f64) -&gt; Self {
        HitRecord {
            p: point,
            normal: n,
            t: hit_t,
        }
    }

    pub fn t(&amp;self) -&gt; f64 {
        self.t
    }

    pub fn normal(&amp;self) -&gt; Vec3 {
        self.normal
    }

    pub fn p(&amp;self) -&gt; Vec3 {
        self.p
    }
}

pub trait Hittable {
    fn hit(&amp;self, r: &amp;Ray, t_min: f64, t_max: f64) -&gt; Option&lt;HitRecord&gt;;
}

<span class="boring">}</span></code></pre></pre>
<p>And here's the sphere:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::hittable::*;
use crate::vec3::*;

pub struct Sphere {
    center: Point3,
    radius: f64,
}

impl Sphere {
    pub fn new() -&gt; Self {
        Sphere {
            center: Point3::new(),
            radius: Default::default(),
        }
    }

    pub fn from(cen: Point3, r: f64) -&gt; Self {
        Sphere {
            center: cen,
            radius: r,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="front-faces-versus-back-faces"><a class="header" href="#front-faces-versus-back-faces">Front Faces Versus Back faces</a></h2>
<p>The second design decision for normals is whether they should always point out. At present, the normal found will always be in the direction of the center to the intersection point (the normal points out). If the ray intersects the sphere from the outside, the normal points against the ray. If the ray intersects the sphere from the inside, the normal (which always points out) points with the ray. Alternatively, we can have the normal always point against the ray. If the ray is outside the sphere, the normal will point outward, but if the ray is inside the sphere, the normal will point inward.</p>
<p><img src="../resources/pictures/fig-1.06-normal-sides.jpg" alt="Possible directions for sphere surface-normal geometry" /></p>
<p>We need to choose one of these possibilities because we will eventually want to determine which side of the surface that the ray is coming from. This is important for objects that are rendered differently on each side, like the text on a two-sided sheet of paper, or for objects that have an inside and an outside, like glass balls.</p>
<p>If we decide to have the normals always point out, then we will need to determine which side the ray is on when we color it. We can figure this out by comparing the ray with the normal. If the ray and the normal face in the same direction, the ray is inside the object, if the ray and the normal face in the opposite direction, then the ray is outside the object. This can be determined by taking the dot product of the two vectors, where if their dot is positive, the ray is inside the sphere.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if Vec3::dot(ray_direction, outward_normal) &gt; 0.0 {
    // ray is inside the sphere
    todo!()
} else {
    // ray is outside the sphere
    todo!()
}

<span class="boring">}</span></code></pre></pre>
<p>If we decide to have the normals always point against the ray, we won't be able to use the dot product to determine which side of the surface the ray is on. Instead, we would need to store that information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut front_face = false;
if Vec3::dot(ray_direction, outward_normal) &gt; 0.0 {
    // ray is inside the sphere
    normal = - outward_normal;
    front_face = false;
} else {
    // ray is outside the sphere
    normal = ouward_normal;
    front_face = true;
}
<span class="boring">}</span></code></pre></pre>
<p>We can set things up so that normals always point “outward” from the surface, or always point against the incident ray. This decision is determined by whether you want to determine the side of the surface at the time of geometry intersection or at the time of coloring. In this book we have more material types than we have geometry types, so we'll go for less work and put the determination at geometry time. This is simply a matter of preference, and you'll see both implementations in the literature.</p>
<p>We add the <code>front_face</code> bool to the <code>HitRecord</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HitRecord {
    p: Point3,
    normal: Vec3,
    t: f64,
    front_face: bool,
}

impl HitRecord {
    pub fn new() -&gt; Self {
        HitRecord {
            p: Point3::new(),
            normal: Vec3::new(),
            t: Default::default(),
            front_face: Default::default(),
        }
    }

    pub fn from(point: Point3, n: Vec3, hit_t: f64, front: bool) -&gt; Self {
        HitRecord {
            p: point,
            normal: n,
            t: hit_t,
            front_face: front,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>We'll also add a function to solve this calculation for us.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
    pub fn set_face_normal(&amp;mut self, r: &amp;Ray, outward_normal: &amp;Vec3) {
        self.front_face = Vec3::dot(&amp;r.direction(), outward_normal) &lt; 0.0;
        self.normal = if self.front_face {
            *outward_normal
        } else {
            -*outward_normal
        };
    }
<span class="boring">}</span></code></pre></pre>
<p>And then we add the surface side determination to the class:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Hittable for Sphere {
    fn hit(&amp;self, r: &amp;crate::ray::Ray, t_min: f64, t_max: f64) -&gt; Option&lt;HitRecord&gt; {
        let oc: Vec3 = r.origin() - self.center;
        let a = r.direction().length_squared();
        let half_b = Vec3::dot(&amp;oc, &amp;r.direction());
        let c = oc.length_squared() - self.radius * self.radius;

        let discriminant = half_b * half_b - a * c;
        if discriminant &lt; 0.0 {
            return None;
        }

        let sqrtd = discriminant.sqrt();

        // Find the nearest root that lies in the acceptable range.
        let mut root = (-half_b - sqrtd) / a;
        if root &lt; t_min || t_max &lt; root {
            root = (-half_b + sqrtd) / a;
            if root &lt; t_min || t_max &lt; root {
                return None;
            }
        }

        let p = r.at(root);
        let mut rec = HitRecord::from(p, (p - self.center) / self.radius, root);
        let outward_normal = (p - self.center) / self.radius;
        rec.set_face_normal(r, &amp;outward_normal);

        Some(rec)
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="a-list-of-hittable-objects"><a class="header" href="#a-list-of-hittable-objects">A List of Hittable Objects</a></h2>
<p>We have a generic object called a <code>Hittable</code> that the ray can intersect with. We now add a class that stores a lisxt of <code>Hittable</code>s :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

use crate::hittable::HitRecord;
use crate::hittable::Hittable;
use crate::ray::*;
use crate::vec3::*;

pub struct HittableList {
    objects: Vec&lt;Rc&lt;dyn Hittable&gt;&gt;,
}

impl HittableList {
    pub fn new() -&gt; Self {
        HittableList {
            objects: Default::default(),
        }
    }

    pub fn from(object: Rc&lt;dyn Hittable&gt;) -&gt; Self {
        HittableList {
            objects: vec![object],
        }
    }

    pub fn clear(&amp;mut self) {
        self.objects.clear();
    }

    pub fn add(&amp;mut self, object: Rc&lt;dyn Hittable&gt;) {
        self.objects.push(object);
    }
}

impl Hittable for HittableList {
    fn hit(&amp;self, r: &amp;Ray, t_min: f64, t_max: f64) -&gt; Option&lt;HitRecord&gt; {
        let mut hit_anything = false;
        let mut closest_so_far = t_max;
        let mut res_rec = HitRecord::new();

        for object in self.objects.iter() {
            if let Some(temp_rec) = object.hit(r, t_min, closest_so_far) {
                hit_anything = true;
                closest_so_far = temp_rec.t();
                res_rec = temp_rec;
            }
        }

        if hit_anything {
            Some(res_rec)
        } else {
            None
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="some-rust-features"><a class="header" href="#some-rust-features">Some Rust features</a></h2>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>todo!()</p>
<h3 id="rc"><a class="header" href="#rc">Rc&lt;&gt;</a></h3>
<p>todo!()</p>
<h2 id="common-constants-and-utility-functions"><a class="header" href="#common-constants-and-utility-functions">Common Constants and Utility Functions</a></h2>
<p>Our general main header file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use std::f64::consts::PI;

// Utility Functions
#[inline]
pub fn degrees_to_radians(degrees: f64) -&gt; f64 {
    degrees * PI / 180.0
}

<span class="boring">}</span></code></pre></pre>
<p>and the new main:</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

use hittable::HitRecord;
use hittable::Hittable;

use crate::color::*;
use crate::hittable_list::*;
use crate::ray::*;
use crate::rtweekend::*;
use crate::sphere::*;
use crate::vec3::*;

mod color;
mod hittable;
mod hittable_list;
mod ray;
mod rtweekend;
mod sphere;
mod vec3;

fn main() {
    // Image
    const ASPECT_RATIO: f64 = 16f64 / 9f64;
    const IMAGE_WIDTH: i32 = 400;
    const IMAGE_HEIGHT: i32 = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;

    // World
    let mut world = HittableList::new();
    world.add(Rc::new(Sphere::from(Point3::from(0f64, 0f64, -1f64), 0.5)));
    world.add(Rc::new(Sphere::from(
        Point3::from(0f64, -100.5f64, -1f64),
        100f64,
    )));

    // Camera

    let viewport_height = 2f64;
    let viewport_width = ASPECT_RATIO * viewport_height;
    let focal_length = 1f64;

    let origin = Point3::from(0f64, 0f64, 0f64);
    let horizontal = Vec3::from(viewport_width, 0f64, 0f64);
    let vertical = Vec3::from(0f64, viewport_height, 0f64);
    let lower_left_corner =
        origin - horizontal / 2f64 - vertical / 2f64 - Vec3::from(0f64, 0f64, focal_length);

    // Render

    println!(&quot;P3\n{IMAGE_WIDTH} {IMAGE_HEIGHT}\n255&quot;);

    for j in (0..IMAGE_HEIGHT).rev() {
        eprintln!(&quot;\rScanlines remaining: {j}&quot;);
        for i in 0..IMAGE_WIDTH {
            let u = (i as f64) / (IMAGE_WIDTH as f64 - 1f64);
            let v = (j as f64) / (IMAGE_HEIGHT as f64 - 1f64);

            let r: Ray = Ray::from(
                origin,
                lower_left_corner + u * horizontal + v * vertical - origin,
            );
            let pixel_color = ray_color(&amp;r, &amp;world);

            write_color(std::io::stdout(), pixel_color).unwrap();
        }
    }
    eprintln!(&quot;\nDone&quot;);
}

fn ray_color(r: &amp;Ray, world: &amp;dyn Hittable) -&gt; Color {
    if let Some(rec) = world.hit(r, 0f64, Infinity) {
        return 0.5 * (rec.normal() + Color::from(1f64, 1f64, 1f64));
    }
    let unit_direction: Vec3 = r.direction().unit_vector();
    let t = 0.5 * (unit_direction.y() + 1f64);
    (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
}
</code></pre></pre>
<p>This yields a picture that is really just a visualization of where the spheres are along with their surface normal. This is often a great way to look at your model for flaws and characteristics.</p>
<p><img src="../resources/pictures/img-1.05-normals-sphere-ground.png" alt="Resulting render of normals-colored sphere with ground" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/chapter_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../chapters/chapter_6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/chapter_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../chapters/chapter_6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src=".././theme/sidebar.js"></script>


    </body>
</html>
