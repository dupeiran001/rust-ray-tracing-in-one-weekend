<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Diffuse Materials - ray-tracing in one weekend</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../chapters/introduce.html">Introduce</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_1.html"><strong aria-hidden="true">1.</strong> Output an Image</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_2.html"><strong aria-hidden="true">2.</strong> The vec3 Struct</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_3.html"><strong aria-hidden="true">3.</strong> Rays, a Simple Camera, and Background</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_4.html"><strong aria-hidden="true">4.</strong> Adding a Sphere</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_5.html"><strong aria-hidden="true">5.</strong> Surface Normals and Multiple Objects</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_6.html"><strong aria-hidden="true">6.</strong> Antialiasing</a></li><li class="chapter-item expanded "><a href="../chapters/chapter_7.html" class="active"><strong aria-hidden="true">7.</strong> Diffuse Materials</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ray-tracing in one weekend</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dupeiran001/rust-ray-tracing-in-one-weekend" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="diffuse-materials"><a class="header" href="#diffuse-materials">Diffuse Materials</a></h1>
<p>Now that we have objects and multiple rays per pixel, we can make some realistic looking materials. We‚Äôll start with diffuse (matte) materials. One question is whether we mix and match geometry and materials (so we can assign a material to multiple spheres, or vice versa) or if geometry and material are tightly bound (that could be useful for procedural objects where the geometry and material are linked). We‚Äôll go with separate ‚Äî which is usual in most renderers ‚Äî but do be aware of the limitation.</p>
<h2 id="a-simple-diffuse-material"><a class="header" href="#a-simple-diffuse-material">A Simple Diffuse Material</a></h2>
<p>Diffuse objects that don't emit light merely take on the color of their surroundings, but they modulate that with their own intrinsic color. Light that reflects off a diffuse surface has its direction randomized. So, if we send three rays into a crack between two diffuse surfaces they will each have different random behavior:</p>
<p><img src="../resources/pictures/fig-1.08-light-bounce.jpg" alt="Light ray bounces" /></p>
<p>They also might be absorbed rather than reflected. The darker the surface, the more likely absorption is. (That‚Äôs why it is dark!) Really any algorithm that randomizes direction will produce surfaces that look matte. One of the simplest ways to do this turns out to be exactly correct for ideal diffuse surfaces. (I used to do it as a lazy hack that approximates mathematically ideal Lambertian.)</p>
<p>(Reader Vassillen Chizhov proved that the lazy hack is indeed just a lazy hack and is inaccurate. The correct representation of ideal Lambertian isn't much more work, and is presented at the end of the chapter.)</p>
<p>There are two unit radius spheres tangent to the hit point \(p\) of a surface. These two spheres have a center of \((P+n)\) and \((P-n)\), where \(n\) is the normal of the surface. The sphere with a center at \((P-n)\) is considered inside the surface, whereas the sphere with center \((P+n)\) is considered outside the surface. Select the tangent unit radius sphere that is on the same side of the surface as the ray origin. Pick a random point \(S\) inside this unit radius sphere and send a ray from the hit point ùêè to the random point \(S\) (this is the vector \((S-P)\):</p>
<p>We need a way to pick a random point in a unit radius sphere. We‚Äôll use what is usually the easiest algorithm: a rejection method. First, pick a random point in the unit cube where x, y, and z all range from ‚àí1 to +1. Reject this point and try again if the point is outside the sphere.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec3{

    #[inline]
        pub fn random() -&gt; Self {
            Vec3 {
                e: (random_double(), random_double(), random_double()),
            }
        }

        #[inline]
        pub fn random_rng(min: f64, max: f64) -&gt; Self {
            Vec3 {
                e: (
                    random_double_rng(min, max),
                    random_double_rng(min, max),
                    random_double_rng(min, max),
                ),
            }
        }

        pub fn random_in_unit_sphere() -&gt; Self {
            loop {
                let p = Vec3::random_rng(-1.0, 1.0);
                if p.length_squared() &lt; 1f64 {
                    return p;
                }
            }
        }
}
<span class="boring">}</span></code></pre></pre>
<p>Then update the <code>ray_color()</code> function to use the new radom direction generator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn ray_color(r: &amp;Ray, world: &amp;dyn Hittable) -&gt; Color {
    if let Some(rec) = world.hit(r, 0f64, Infinity) {
        let target: Point3 = rec.p() + rec.normal() + Vec3::random_in_unit_sphere();
        return 0.5 * ray_color(&amp;Ray::from(rec.p(), target - rec.p()), world);
    }
    let unit_direction: Vec3 = r.direction().unit_vector();
    let t = 0.5 * (unit_direction.y() + 1f64);
    (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limiting-the-number-of-child-rays"><a class="header" href="#limiting-the-number-of-child-rays">Limiting the Number of Child Rays</a></h2>
<p>There's one potential problem lurking here. Notice that the <code>ray_color</code> function is recursive. When will it stop recursing? When it fails to hit anything. In some cases, however, that may be a long time ‚Äî long enough to blow the stack. To guard against that, let's limit the maximum recursion depth, returning no light contribution at the maximum depth:</p>
<pre><pre class="playground"><code class="language-rust">
fn main() {
    // Image
<span class="boring">   const ASPECT_RATIO: f64 = 16f64 / 9f64;
</span><span class="boring">   const IMAGE_WIDTH: i32 = 400;
</span><span class="boring">   const IMAGE_HEIGHT: i32 = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;
</span><span class="boring">   const SAMPLES_PER_PIXEL: i32 = 100;
</span>    const MAX_DEPTH: i32 = 50;

<span class="boring">   // World
</span><span class="boring">   let mut world = HittableList::new();
</span><span class="boring">   world.add(Rc::new(Sphere::from(Point3::from(0f64, 0f64, -1f64), 0.5)));
</span><span class="boring">   world.add(Rc::new(Sphere::from(
</span><span class="boring">       Point3::from(0f64, -100.5f64, -1f64),
</span><span class="boring">       100f64,
</span><span class="boring">   )));
</span><span class="boring">
</span><span class="boring">   // Camera
</span><span class="boring">
</span><span class="boring">   let cam = Camera::new();
</span><span class="boring">
</span><span class="boring">   // Render
</span><span class="boring">
</span><span class="boring">   println!(&quot;P3\n{IMAGE_WIDTH} {IMAGE_HEIGHT}\n255&quot;);
</span><span class="boring">
</span>    for j in (0..IMAGE_HEIGHT).rev() {
<span class="boring">       eprintln!(&quot;\rScanlines remaining: {j}&quot;);
</span>        for i in 0..IMAGE_WIDTH {
<span class="boring">           let mut pixel_color: Color = Color::from(0.0, 0.0, 0.0);
</span>            for s in 0..SAMPLES_PER_PIXEL {
<span class="boring">               let u = (i as f64 + random_double()) / (IMAGE_WIDTH - 1) as f64;
</span><span class="boring">               let v = (j as f64 + random_double()) / (IMAGE_HEIGHT - 1) as f64;
</span><span class="boring">               let r = cam.get_ray(u, v);
</span><span class="boring">
</span>                pixel_color += ray_color(&amp;r, &amp;world, MAX_DEPTH);
            }
<span class="boring">           write_color(std::io::stdout(), pixel_color, SAMPLES_PER_PIXEL).unwrap();
</span>        }
    }
<span class="boring">   eprintln!(&quot;\nDone&quot;);
</span>}

fn ray_color(r: &amp;Ray, world: &amp;dyn Hittable, depth: i32) -&gt; Color {
    if depth &lt;= 0 {
        return Color::from(0.0, 0.0, 0.0);
    }

<span class="boring">   if let Some(rec) = world.hit(r, 0f64, Infinity) {
</span><span class="boring">       let target: Point3 = rec.p() + rec.normal() + Vec3::random_in_unit_sphere();
</span>        return 0.5 * ray_color(&amp;Ray::from(rec.p(), target - rec.p()), world, depth - 1);
<span class="boring">           }
</span><span class="boring">   let unit_direction: Vec3 = r.direction().unit_vector();
</span><span class="boring">   let t = 0.5 * (unit_direction.y() + 1f64);
</span><span class="boring">   (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
</span>}</code></pre></pre>
<p>This gives us:</p>
<p><img src="../resources/pictures/img-1.07-first-diffuse.png" alt="First render of a difuse sphere" /></p>
<p>Note: If you met up with some performance issue, try using the release mode: <code>cargo build --release</code></p>
<h2 id="using-gamma-correction-for-accurate-color-intensity"><a class="header" href="#using-gamma-correction-for-accurate-color-intensity">Using Gamma Correction for Accurate Color Intensity</a></h2>
<p>Note the shadowing under the sphere. This picture is very dark, but our spheres only absorb half the energy on each bounce, so they are 50% reflectors. If you can‚Äôt see the shadow, don‚Äôt worry, we will fix that now. These spheres should look pretty light (in real life, a light grey). The reason for this is that almost all image viewers assume that the image is ‚Äúgamma corrected‚Äù, meaning the 0 to 1 values have some transform before being stored as a byte. There are many good reasons for that, but for our purposes we just need to be aware of it. To a first approximation, we can use ‚Äúgamma 2‚Äù which means raising the color to the power 1/ùëîùëéùëöùëöùëé, or in our simple case ¬Ω, which is just square-root:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn write_color&lt;T: std::io::Write&gt;(
    mut fmt: T,
    pixel_color: Color,
    samples_per_pixel: i32,
) -&gt; std::io::Result&lt;()&gt; {

// Divide the color by the number of samples and gamma-correct for gamma=2.0

let scale = 1.0 / samples_per_pixel as f64;

r = (scale * r).sqrt();
g = (scale * g).sqrt();
b = (scale * b).sqrt();
}

<span class="boring">}</span></code></pre></pre>
<p>That yields light grey, as we desire:</p>
<p><img src="../resources/pictures/img-1.08-gamma-correct.png" alt="Diffuse sphere, with gamma correction" /></p>
<h2 id="fixing-shadow-acne"><a class="header" href="#fixing-shadow-acne">Fixing Shadow Acne</a></h2>
<p>There‚Äôs also a subtle bug in there. Some of the reflected rays hit the object they are reflecting off of not at exactly \(t=0\), but instead at \(t=‚àí0.0000001\) or \(t=0.00000001\) or whatever floating point approximation the sphere intersector gives us. So we need to ignore hits very near zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(rec) = world.hit(r, 0.0001f64, Infinity) {
    let target: Point3 = rec.p() + rec.normal() + Vec3::random_in_unit_sphere();
    return 0.5 * ray_color(&amp;Ray::from(rec.p(), target - rec.p()), world, depth - 1);
}
<span class="boring">}</span></code></pre></pre>
<p>This gets rid of the shadow acne problem. Yes it is really called that.</p>
<h2 id="true-lambertian-reflection"><a class="header" href="#true-lambertian-reflection">True Lambertian Reflection</a></h2>
<p>The rejection method presented here produces random points in the unit ball offset along the surface normal. This corresponds to picking directions on the hemisphere with high probability close to the normal, and a lower probability of scattering rays at grazing angles. This distribution scales by the \(\cos^3(\phi)\) where \(\phi\) is the angle from the normal. This is useful since light arriving at shallow angles spreads over a larger area, and thus has a lower contribution to the final color.</p>
<p>However, we are interested in a Lambertian distribution, which has a distribution of \(\cos(\phi)\). True Lambertian has the probability higher for ray scattering close to the normal, but the distribution is more uniform. This is achieved by picking random points on the surface of the unit sphere, offset along the surface normal. Picking random points on the unit sphere can be achieved by picking random points in the unit sphere, and then normalizing those.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec3 {
    pub fn random_unit_vector() -&gt; Self {
            Vec3::unit_vector(&amp;Vec3::random_in_unit_sphere())
        }
}

<span class="boring">}</span></code></pre></pre>
<p>This <code>random_unit_vector()</code> is a drop-in replacement for the existing <code>random_in_unit_sphere()</code> funciton.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn ray_color(r: &amp;Ray, world: &amp;dyn Hittable, depth: i32) -&gt; Color {
<span class="boring">   if depth &lt;= 0 {
</span><span class="boring">       return Color::from(0.0, 0.0, 0.0);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   if let Some(rec) = world.hit(r, 0.0001f64, Infinity) {
</span>        let target: Point3 = rec.p() + rec.normal() + Vec3::random_unit_vector();
<span class="boring">       return 0.5 * ray_color(&amp;Ray::from(rec.p(), target - rec.p()), world, depth - 1);
</span><span class="boring">   }
</span><span class="boring">   let unit_direction: Vec3 = r.direction().unit_vector();
</span><span class="boring">   let t = 0.5 * (unit_direction.y() + 1f64);
</span><span class="boring">   (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
</span>}
<span class="boring">}</span></code></pre></pre>
<p>After rendering we get a similar image:</p>
<p><img src="../resources/pictures/img-1.09-correct-lambertian.png" alt="Correct render of Lambertian sphere" /></p>
<p>It's hard to tell the difference between these two diffuse methods, given that our scene of two spheres is so simple, but you should be able to notice two important visual differences:</p>
<ul>
<li>The shadows are less pronounced after the change</li>
<li>Both spheres are lighter in appearance after the change</li>
</ul>
<p>Both of these changes are due to the more uniform scattering of the light rays, fewer rays are scattering toward the normal. This means that for diffuse objects, they will appear lighter because more light bounces toward the camera. For the shadows, less light bounces straight-up, so the parts of the larger sphere directly underneath the smaller sphere are brighter.</p>
<h2 id="an-alternative-diffuse-formulation"><a class="header" href="#an-alternative-diffuse-formulation">An Alternative Diffuse Formulation</a></h2>
<p>The initial hack presented in this book lasted a long time before it was proven to be an incorrect approximation of ideal Lambertian diffuse. A big reason that the error persisted for so long is that it can be difficult to:</p>
<ul>
<li>Mathematically prove that the probability distribution is incorrect</li>
<li>Intuitively explain why a \(\cos(\phi)\) distribution is desirable (and what it would look like)</li>
</ul>
<p>Not a lot of common, everyday objects are perfectly diffuse, so our visual intuition of how these objects behave under light can be poorly formed.</p>
<p>In the interest of learning, we are including an intuitive and easy to understand diffuse method. For the two methods above we had a random vector, first of random length and then of unit length, offset from the hit point by the normal. It may not be immediately obvious why the vectors should be displaced by the normal.</p>
<p>A more intuitive approach is to have a uniform scatter direction for all angles away from the hit point, with no dependence on the angle from the normal. Many of the first raytracing papers used this diffuse method (before adopting Lambertian diffuse).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec3{

    pub fn random_in_hemisphere(normal: &amp;Vec3) -&gt; Self {
        let in_unit_sphere = Vec3::random_in_unit_sphere();
        if Vec3::dot(&amp;in_unit_sphere, normal) &gt; 0.0 {
            in_unit_sphere
        } else {
            -in_unit_sphere
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Plugging the new formula into the <code>ray_color()</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ray_color(r: &amp;Ray, world: &amp;dyn Hittable, depth: i32) -&gt; Color {
<span class="boring">   if depth &lt;= 0 {
</span><span class="boring">       return Color::from(0.0, 0.0, 0.0);
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   if let Some(rec) = world.hit(r, 0.0001f64, Infinity) {
</span>        let target: Point3 = rec.p() + Vec3::random_in_hemisphere(&amp;rec.normal());
<span class="boring">       return 0.5 * ray_color(&amp;Ray::from(rec.p(), target - rec.p()), world, depth - 1);
</span><span class="boring">   }
</span><span class="boring">   let unit_direction: Vec3 = r.direction().unit_vector();
</span><span class="boring">   let t = 0.5 * (unit_direction.y() + 1f64);
</span><span class="boring">   (1f64 - t) * Color::from(1f64, 1f64, 1f64) + t * Color::from(0.5, 0.7, 1f64)
</span>}

<span class="boring">}</span></code></pre></pre>
<p>Gives us the following image:</p>
<p><img src="../resources/pictures/img-1.10-rand-hemispherical.png" alt="Rendering of diffuse spheres with hemispherical scattering" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapters/chapter_6.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapters/chapter_6.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src=".././theme/sidebar.js"></script>


    </body>
</html>
